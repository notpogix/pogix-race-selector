<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Marble Maze ‚Äî Instant Race</title>
  <style>
    :root{--bg:#0b1020;--panel:#0f1724;--accent:#6ee7b7;--muted:#94a3b8}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #071a2a 100%);font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    .app{display:flex;min-height:100vh;gap:12px;padding:18px}
    .left{flex:1;min-width:760px;background:transparent;display:flex;flex-direction:column}
    .topbar{display:flex;gap:10px;align-items:center;margin-bottom:10px}
    .panel{background:rgba(255,255,255,0.04);border-radius:12px;padding:12px;color:#dfe9f3;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    button,select,input[type=text]{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#dfe9f3;padding:8px 10px;border-radius:8px}
    button.primary{background:linear-gradient(90deg,var(--accent),#60a5fa);color:#041422;border:font-weight:700}
    #canvasWrap{flex:1;overflow:auto;border-radius:12px}
    canvas#world{display:block; background: linear-gradient(180deg,#083044 0%, #021019 100%);}
    .right{width:360px;display:flex;flex-direction:column;gap:12px}
    .namesList{max-height:260px;overflow:auto;padding:8px}
    .nameItem{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px}
    .ballBadge{width:36px;height:36px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;box-shadow:0 4px 10px rgba(2,6,23,0.6)}
    .rankBox{position:fixed;right:28px;top:24px;background:rgba(255,255,255,0.03);padding:10px;border-radius:10px;color:#dfe9f3;width:240px}
    .controls{display:flex;flex-direction:column;gap:8px}
    .small{font-size:12px;color:var(--muted)}
    .modeRow{display:flex;gap:8px}
    .footer{font-size:12px;color:var(--muted);text-align:center;margin-top:8px}
    .overlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(3,6,15,0.9);padding:18px;border-radius:12px;color:#fff;z-index:60;box-shadow:0 20px 60px rgba(0,0,0,0.6)}
    .hidden{display:none}
    .bracket{max-height:300px;overflow:auto;padding:8px}
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="topbar panel">
        <div style="display:flex;align-items:center;gap:8px">
          <strong>Marble Maze ‚Äî Instant Race</strong>
          <span class="small">(no login ‚Äî type names, choose mode & go)</span>
        </div>

        <div style="margin-left:12px;display:flex;gap:8px;align-items:center">
          <select id="modeSelect" title="Game mode">
            <option value="winner">Winner Selection</option>
            <option value="elimination">Elimination (Last Out)</option>
          </select>
          <button id="startBtn" class="primary">Start Race</button>
          <button id="stopBtn">Stop</button>
          <button id="shuffleBtn">Shuffle Maze</button>
          <label class="small">Gravity <input id="gravity" type="range" min="0.2" max="2.5" step="0.05" value="1"></label>
          <label class="small">TimeScale <input id="timescale" type="range" min="0.3" max="1.6" step="0.05" value="1"></label>
        </div>
      </div>

      <div id="canvasWrap" class="panel">
        <!-- Large scrollable map; canvas inside -->
        <canvas id="world" width="900" height="2000"></canvas>
      </div>

      <div class="panel" style="margin-top:10px;display:flex;justify-content:space-between;align-items:center">
        <div class="small">Each round attempts to be ~60s by default ‚Äî you can change gravity and timescale.</div>
        <div>
          <label class="small">Bracket View <input type="checkbox" id="bracketToggle"></label>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel controls">
        <div style="display:flex;gap:8px">
          <input id="nameInput" type="text" placeholder="Type a name and press Enter" />
          <button id="addBtn">Add</button>
        </div>
        <div class="small">Players (drag to reorder)</div>
        <div id="players" class="namesList"></div>
        <div style="display:flex;gap:8px">
          <button id="clearBtn">Clear</button>
          <button id="randomBtn">Add 6 Random</button>
        </div>
        <div class="small">Options</div>
        <div style="display:flex;flex-direction:column;gap:6px">
          <label><input type="checkbox" id="autoContinue" checked> Auto-continue rounds (keep playing till all winners removed)</label>
          <label><input type="checkbox" id="shuffleEachRound"> Shuffle maze each round</label>
          <label><input type="checkbox" id="keepMapLarge" checked> Large map (long races)</label>
        </div>
      </div>

      <div class="panel" id="rankPanel">
        <strong>Live Rankings</strong>
        <div id="ranks" style="margin-top:8px"></div>
      </div>

      <div class="panel bracket hidden" id="bracketPanel">
        <strong>Bracket / Tournament</strong>
        <div id="bracketArea"></div>
      </div>

      <div class="panel">
        <strong>Last Result</strong>
        <div id="lastResult" style="margin-top:8px" class="small">‚Äî</div>
        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="removeWinnerBtn" class="hidden">Remove Winner & Continue</button>
          <button id="restartBtn">Restart Race</button>
          <button id="exportBtn">Export Players</button>
        </div>
      </div>

      <div class="footer panel small">Tip: Scroll the map vertically to see full course. Use shuffle + bracket mode for tournaments.</div>
    </div>
  </div>

  <div id="winnerOverlay" class="overlay hidden"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
  // Marble Maze ‚Äî Single-file implementation using Matter.js
  // Features implemented based on your spec:
  // - vertical layout, large map, scrollable
  // - mode selection (winner selection / elimination)
  // - add names (press Enter or Add button)
  // - unique color and letter badge, 3D-like shading, physics collisions
  // - shuffle maze, gravity slider, timescale, bracket/view
  // - live ranking by distance to finish, elimination/winner handling

  const { Engine, Render, World, Bodies, Body, Events, Runner, Composite, Composites, Constraint } = Matter;

  // DOM hooks
  const canvas = document.getElementById('world');
  const ctx = canvas.getContext('2d');
  const playersDiv = document.getElementById('players');
  const ranksDiv = document.getElementById('ranks');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const addBtn = document.getElementById('addBtn');
  const nameInput = document.getElementById('nameInput');
  const clearBtn = document.getElementById('clearBtn');
  const randomBtn = document.getElementById('randomBtn');
  const modeSelect = document.getElementById('modeSelect');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const gravityRange = document.getElementById('gravity');
  const timescaleRange = document.getElementById('timescale');
  const winnerOverlay = document.getElementById('winnerOverlay');
  const removeWinnerBtn = document.getElementById('removeWinnerBtn');
  const lastResult = document.getElementById('lastResult');
  const restartBtn = document.getElementById('restartBtn');
  const exportBtn = document.getElementById('exportBtn');
  const bracketToggle = document.getElementById('bracketToggle');
  const bracketPanel = document.getElementById('bracketPanel');
  const bracketArea = document.getElementById('bracketArea');

  // World settings
  let canvasWidth = canvas.width = 900;
  let canvasHeight = canvas.height = (document.getElementById('canvasWrap').clientHeight>0? 2000 : 2000); // large vertical world
  let finishY = canvasHeight - 80;
  const startY = 80;
  let engine = Engine.create();
  let runner = null;
  let worldBodies = [];

  engine.world.gravity.y = parseFloat(gravityRange.value);
  engine.timing.timeScale = parseFloat(timescaleRange.value);

  // State
  let players = []; // {id,name,color,letter,body,finishedAt,rank}
  let balls = [];
  let pegs = [];
  let obstacles = [];
  let finishOrder = [];
  let running = false;
  let roundCount = 0;
  let eliminationOrder = [];

  // Utilities
  function uid(prefix='p'){return prefix + Math.random().toString(36).slice(2,9)}
  function pickColor(seed){ // deterministic-ish color from seed
    let h = Math.abs(hashCode(seed)) % 360; return `hsl(${h} 70% 55%)`;
  }
  function hashCode(s){let h=0; for(let i=0;i<s.length;i++)h=(h<<5)-h+s.charCodeAt(i)|0; return h}

  // UI: add player
  function addPlayer(name){ if(!name) return; name = name.trim(); if(!name) return;
    const id = uid('pl_');
    const letter = name[0].toUpperCase();
    const color = pickColor(name + Math.random()); // use random part to avoid identical colors for same name
    const player = {id, name, color, letter, body:null, finishedAt:null, rank:null};
    players.push(player); renderPlayers();
  }
  function renderPlayers(){ playersDiv.innerHTML=''; players.forEach((p,i)=>{
      const el = document.createElement('div'); el.className='nameItem'; el.draggable=true;
      el.innerHTML = `<div class="ballBadge" style="background:${p.color};color:#021022">${p.letter}</div><div style="flex:1"><strong>${p.name}</strong><div class="small">#${i+1}</div></div><button data-id="${p.id}">‚úñ</button>`;
      playersDiv.appendChild(el);
      el.querySelector('button').onclick = ()=>{ players = players.filter(x=>x.id!==p.id); renderPlayers(); }

      // reorder by drag
      el.addEventListener('dragstart', e=>{ e.dataTransfer.setData('text/plain', p.id) })
      el.addEventListener('dragover', e=>{ e.preventDefault() })
      el.addEventListener('drop', e=>{ e.preventDefault(); const from = e.dataTransfer.getData('text'); const to = p.id; reorderPlayers(from,to); })
    })}

  function reorderPlayers(fromId,toId){ const fromIdx = players.findIndex(x=>x.id===fromId); const toIdx = players.findIndex(x=>x.id===toId); if(fromIdx<0||toIdx<0) return; const [item]=players.splice(fromIdx,1); players.splice(toIdx,0,item); renderPlayers(); }

  nameInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ addPlayer(nameInput.value); nameInput.value=''; } })
  addBtn.onclick = ()=>{ addPlayer(nameInput.value); nameInput.value=''; }
  clearBtn.onclick = ()=>{ players=[]; renderPlayers(); }
  randomBtn.onclick = ()=>{ const sample = ['Ava','Liam','Noah','Mia','Zoe','Kai','Rin','Omar','Nia','Leo','Isha','Raj']; for(let i=0;i<6;i++){ addPlayer(sample[Math.floor(Math.random()*sample.length)] + (Math.random()>0.5?'':' '+Math.floor(Math.random()*99))); } }

  // Maze generator (pegs) ‚Äî plinko-style pegs
  function generatePegs(){ // clear existing
    pegs.forEach(b=>World.remove(engine.world,b)); pegs=[];
    const cols = 9; const spacingX = canvasWidth / cols; const spacingY = 90; let offset=0;
    for(let y=startY+60;y<finishY-140;y+=spacingY){
      offset = (offset===0? spacingX/2 : 0);
      for(let x=offset+40;x<canvasWidth-40;x+=spacingX){
        if(Math.random() < 0.85){ const r=8 + Math.random()*4; const peg = Bodies.circle(x + (Math.random()*18-9), y + (Math.random()*12-6), r, {isStatic:true,friction:0,render:{visible:false}}); pegs.push(peg); }
      }
    }
    pegs.forEach(p=>World.add(engine.world,p));
  }

  function addBorders(){ const thickness = 40; const left = Bodies.rectangle(-thickness/2, canvasHeight/2, thickness, canvasHeight, {isStatic:true}); const right = Bodies.rectangle(canvasWidth+thickness/2, canvasHeight/2, thickness, canvasHeight, {isStatic:true}); const top = Bodies.rectangle(canvasWidth/2, -thickness/2, canvasWidth, thickness, {isStatic:true}); const finish = Bodies.rectangle(canvasWidth/2, finishY+20, canvasWidth, 40, {isStatic:true, isSensor:true, label:'finish'});
    World.add(engine.world,[left,right,top,finish]); obstacles.push(left,right,top,finish);
  }

  function clearWorld(){ World.clear(engine.world); pegs=[]; obstacles=[]; balls=[]; finishOrder=[]; }

  function spawnBalls(){ // spawn at top spaced horizontally
    const count = players.length; const gap = Math.min(72, (canvasWidth-200)/Math.max(1,count)); const startX = (canvasWidth - (count-1)*gap)/2;
    players.forEach((p,i)=>{
      const x = startX + i*gap + (Math.random()*14-7); const y = startY - (10 + Math.random()*10);
      const radius = 20; const body = Bodies.circle(x, y, radius, { restitution:0.2, friction:0.02, frictionAir:0.02, density:0.002, label:'player' });
      body.plugin = {playerId:p.id}; p.body = body; p.finishedAt = null; p.rank = null; World.add(engine.world, body); balls.push({player:p, body, radius});
    });
  }

  function drawScene(){ ctx.clearRect(0,0,canvasWidth,canvasHeight);
    // background gradient
    const g = ctx.createLinearGradient(0,0,0,canvasHeight); g.addColorStop(0,'#082333'); g.addColorStop(1,'#021018'); ctx.fillStyle=g; ctx.fillRect(0,0,canvasWidth,canvasHeight);

    // finish line
    ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(0,finishY,canvasWidth,6);

    // pegs
    pegs.forEach(p=>{ ctx.beginPath(); ctx.fillStyle='rgba(200,220,255,0.06)'; ctx.arc(p.position.x,p.position.y,p.circleRadius,0,Math.PI*2); ctx.fill(); })

    // balls
    balls.forEach(b=>{
      const pos = b.body.position; const r = b.radius;
      // 3d-like radial gradient
      const grad = ctx.createRadialGradient(pos.x - r*0.4, pos.y - r*0.6, r*0.1, pos.x, pos.y, r*1.1);
      grad.addColorStop(0,'rgba(255,255,255,0.8)'); grad.addColorStop(0.18,'rgba(255,255,255,0.2)'); grad.addColorStop(0.6,'rgba(0,0,0,0.12)');
      // base color
      ctx.beginPath(); ctx.arc(pos.x,pos.y,r,0,Math.PI*2); ctx.fillStyle = b.player.color; ctx.fill();
      ctx.fillStyle = grad; ctx.fill();
      // rim / shadow
      ctx.beginPath(); ctx.arc(pos.x,pos.y,r,0,Math.PI*2); ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=2; ctx.stroke();
      // letter
      ctx.fillStyle = '#021022'; ctx.font = `${r}px Inter, sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(b.player.letter, pos.x, pos.y+2);
    })

    // draw top start area
    ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fillRect(0,0,canvasWidth, startY+20);
    // draw finish flags
    ctx.fillStyle='rgba(100,255,200,0.06)'; ctx.fillRect(0,finishY-30,canvasWidth,30);
  }

  // Rankings by distance to finish (smaller y -> further from finish)
  function updateRanks(){ const list = players.filter(p=>p.body).map(p=>{
      const pos = p.body.position; const dist = Math.max(0, finishY - pos.y); const perc = Math.max(0, Math.min(100, (1 - dist/(finishY-startY))*100)); return {p,dist,perc}
    }); list.sort((a,b)=>a.dist - b.dist); // smaller dist = closer to finish
    ranksDiv.innerHTML = '';
    list.forEach((it,i)=>{
      const el = document.createElement('div'); el.style.display='flex'; el.style.justifyContent='space-between'; el.style.alignItems='center'; el.style.marginBottom='6px'; el.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div class="ballBadge" style="background:${it.p.color};color:#021022">${it.p.letter}</div><div style="min-width:90px">${it.p.name}</div></div><div class="small">${Math.round(it.perc)}%</div>`;
      ranksDiv.appendChild(el);
    });
  }

  // Finish detection
  Events.on(engine, 'collisionStart', function(event){ const pairs = event.pairs; pairs.forEach(pair=>{ const a=pair.bodyA, b=pair.bodyB; [a,b].forEach(body=>{ if(body.label==='finish'){ // other body finished
          const other = body===a?b:a; if(other.label==='player'){ const pl = players.find(x=>x.id===other.plugin.playerId); if(pl && pl.finishedAt==null){ pl.finishedAt = Date.now(); finishOrder.push({player:pl, time:pl.finishedAt}); pl.rank = finishOrder.length; checkRoundFinish(); } }
        } }) }) });

  function checkRoundFinish(){ if(modeSelect.value==='winner'){ // show first
      if(finishOrder.length>0 && !document.getElementById('removeWinnerBtn').classList.contains('hidden')){ }
      if(finishOrder.length>=1){ const first = finishOrder[0]; showWinner(first.player); }
    } else if(modeSelect.value==='elimination'){
      // elimination: when all players finished, eliminate last one
      if(finishOrder.length === players.length){ // determine last
        const last = finishOrder[finishOrder.length-1].player; eliminationOrder.push(last); announceElimination(last);
        // remove last after short delay and restart with remaining players
        setTimeout(()=>{ players = players.filter(p=>p.id!==last.id); finishOrder=[]; clearBodiesAndRespawn(); roundCount++; if(players.length>1){ if(document.getElementById('shuffleEachRound').checked) regenerateAndShuffle(); startRound(); } else { showFinalWinner(players[0] || last); } }, 1200);
      }
    }
  }

  function showWinner(player){ winnerOverlay.classList.remove('hidden'); winnerOverlay.innerHTML = `<div style="display:flex;flex-direction:column;align-items:center;gap:10px"><div style="font-size:22px;">Winner</div><div class="ballBadge" style="width:72px;height:72px;background:${player.color};font-size:36px;color:#021022">${player.letter}</div><div style="font-size:18px">${player.name}</div><div style="display:flex;gap:8px"><button id="owRemove">Remove Winner & Continue</button><button id="owKeep">Keep & Restart</button></div></div>`;
    document.getElementById('owRemove').onclick = ()=>{ // remove from players and continue
      winnerOverlay.classList.add('hidden'); players = players.filter(p=>p.id!==player.id); lastResult.innerText = `Removed winner: ${player.name}`; finishOrder=[]; clearBodiesAndRespawn(); startRound(); }
    document.getElementById('owKeep').onclick = ()=>{ winnerOverlay.classList.add('hidden'); lastResult.innerText = `Kept winner: ${player.name}`; finishOrder=[]; clearBodiesAndRespawn(); startRound(); }
  }

  function announceElimination(player){ // show small overlay
    winnerOverlay.classList.remove('hidden'); winnerOverlay.innerHTML = `<div style="display:flex;flex-direction:column;align-items:center;gap:10px"><div style="font-size:18px;color:#f97316">Eliminated</div><div class="ballBadge" style="width:64px;height:64px;background:${player.color};font-size:32px;color:#021022">${player.letter}</div><div style="font-size:16px">${player.name}</div></div>`;
    setTimeout(()=>{ winnerOverlay.classList.add('hidden'); }, 1100);
  }

  function showFinalWinner(player){ winnerOverlay.classList.remove('hidden'); winnerOverlay.innerHTML = `<div style="display:flex;flex-direction:column;align-items:center;gap:10px"><div style="font-size:22px;">üèÜ Tournament Winner</div><div class="ballBadge" style="width:96px;height:96px;background:${player.color};font-size:48px;color:#021022">${player.letter}</div><div style="font-size:20px">${player.name}</div></div>`; lastResult.innerText = `Final Winner: ${player.name}`; }

  function clearBodiesAndRespawn(){ // remove only dynamic bodies
    // remove player bodies
    players.forEach(p=>{ if(p.body) World.remove(engine.world,p.body); p.body=null; p.finishedAt=null; p.rank=null; }); balls=[]; finishOrder=[];
    spawnBalls();
  }

  function startRound(){ if(players.length<1) { alert('Add at least one player'); return; }
    // reset world
    clearWorld(); engine = Engine.create(); engine.world.gravity.y = parseFloat(gravityRange.value);
    addBorders(); generatePegs(); spawnBalls(); running = true; finishOrder=[]; eliminationOrder=[]; roundCount++;

    // Runner
    if(runner) Runner.stop(runner);
    runner = Runner.create(); Runner.run(runner, engine);

    // animation loop
    (function loop(){ if(!running) return; Engine.update(engine, 1000/60); drawScene(); updateRanks(); requestAnimationFrame(loop); })();
    // ensure minimum ~60s per round by adjusting world height & friction if needed ‚Äî we rely on large map & pegs
  }

  function stopRound(){ running=false; if(runner) Runner.stop(runner); }

  // shuffle/regenerate maze
  function regenerateAndShuffle(){ generatePegs(); }

  // UI bindings
  startBtn.onclick = ()=>{ if(usersAreDuplicate()){ // avoid visual identical ties ‚Äî randomize slight colors and positions
        // shuffle seed
      }
      if(document.getElementById('shuffleEachRound').checked){ regenerateAndShuffle(); }
      startRound(); }
  stopBtn.onclick = ()=>{ stopRound(); }
  shuffleBtn.onclick = ()=>{ regenerateAndShuffle(); }
  gravityRange.oninput = ()=>{ engine.world.gravity.y = parseFloat(gravityRange.value); }
  timescaleRange.oninput = ()=>{ engine.timing.timeScale = parseFloat(timescaleRange.value); }

  restartBtn.onclick = ()=>{ finishOrder=[]; eliminationOrder=[]; clearBodiesAndRespawn(); startRound(); }
  removeWinnerBtn.onclick = ()=>{ if(finishOrder.length>0){ const w = finishOrder[0].player; players = players.filter(p=>p.id!==w.id); finishOrder=[]; clearBodiesAndRespawn(); startRound(); } }

  exportBtn.onclick = ()=>{ const data = players.map(p=>p.name).join(', '); prompt('Players (copy):', data); }

  bracketToggle.onchange = ()=>{ if(bracketToggle.checked){ bracketPanel.classList.remove('hidden'); updateBracket(); } else { bracketPanel.classList.add('hidden'); }}

  function updateBracket(){ // simple bracket visualization
    bracketArea.innerHTML=''; const names = players.map(p=>p.name); if(names.length===0){ bracketArea.innerHTML='<div class="small">No players</div>'; return;} let html=''; names.forEach((n,i)=>{ html += `<div style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.03)">${i+1}. ${n}</div>` }); bracketArea.innerHTML = html; }

  function usersAreDuplicate(){ // check for name+letter+color duplicates; if exact duplicates exist we'll nudge colors
    const seen = {}; let dup=false; players.forEach(p=>{ const k = `${p.name}|${p.letter}`; if(seen[k]) dup=true; seen[k]=true; }); if(dup){ players.forEach(p=>{ p.color = pickColor(p.name + Math.random()); }); renderPlayers(); } return dup; }

  // Ensure that ties are handled: if two finished within 60ms treat as tie and randomize order
  function finalizeFinishOrderIfTies(){ if(finishOrder.length>1){ // sort by time, detect ties
      finishOrder.sort((a,b)=>a.time-b.time);
      for(let i=0;i<finishOrder.length-1;i++){
        if(Math.abs(finishOrder[i].time - finishOrder[i+1].time) < 60){ // tie
          // randomize the small block
          const block = [finishOrder[i], finishOrder[i+1]]; if(Math.random()>0.5) { finishOrder[i]=block[1]; finishOrder[i+1]=block[0]; }
        }
      }
    }
  }

  // initial setup
  generatePegs(); addBorders(); renderPlayers(); drawScene();

  // make scrollable canvas responsive to container height
  window.addEventListener('resize', ()=>{ const h = document.getElementById('canvasWrap').clientHeight; canvasHeight = canvas.height = Math.max(1200, h*2); finishY = canvasHeight - 80; generatePegs(); drawScene(); });

  // auto-run demo if no players
  // helpful instructions for the user
  </script>
</body>
</html>
